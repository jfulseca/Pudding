module Pudding.Types.Internal.Position

( Angle
, Position(..)
, SphereAngles(..)
, createSpherical
, move
, positionEq
) where

type Angle = Double

roundDown :: Double -> Double
roundDown = fromIntegral . floor

fmod :: Double -> Double -> Double
fmod x y = x - n * y
  where n = roundDown $ x / y 

moveAngle :: Angle -> Angle -> Angle
moveAngle a1 a2 = (a1 + a2) `fmod` (2 * pi)

data SphereAngles = SphereAngles {
  polar :: Angle
, azimuthal :: Angle
} deriving (Eq, Show)

sphereAnglesEq :: SphereAngles -> SphereAngles -> Bool
sphereAnglesEq (SphereAngles theta1 phi1) (SphereAngles theta2 phi2) =
  ((theta1 `fmod` (2 * pi))) `doubleEq` ((theta2 `fmod` (2 * pi))) &&
  ((phi1 `fmod` (2 * pi))) `doubleEq` ((phi2 `fmod` (2 * pi)))

rotate :: SphereAngles -> SphereAngles -> SphereAngles
rotate (SphereAngles theta1 phi1) (SphereAngles theta2 phi2) =
  let theta' = theta1 `moveAngle` theta2
      (theta'', phi')
        | theta' < 0 = (-theta', phi1 `moveAngle` pi)
        | theta' > pi = (2 * pi - theta', phi1 `moveAngle` pi)
        | otherwise = (theta', phi1)
      phi'' = phi' `moveAngle` phi2
  in SphereAngles theta'' phi''

data Position = SpherePosition SphereAngles | DiskPosition Int
  deriving (Eq, Show)

positionEq :: Position -> Position -> Bool
positionEq (SpherePosition p1) (SpherePosition p2) =
  p11`

createSpherical :: Angle -> Angle -> Position
createSpherical theta phi =
  SpherePosition $ SphereAngles theta' phi'
  where theta' = theta `fmod` (2 * pi)
        phi' = phi `fmod` (2 * pi)

move :: Position -> Position -> Position
move (SpherePosition p1) (SpherePosition p2) =
  SpherePosition $ p1 `rotate` p2
move _ _ = undefined
