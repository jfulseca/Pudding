module Pudding.Types.Internal.Position

( Angle
, Position(..)
, SphereAngles(..)
, createSpherical
, move
, positionEq
) where

import Pudding.Utilities.DoubleFunctions

type Angle = Double

roundDown :: Double -> Double
roundDown = fromIntegral . floor

fmod :: Double -> Double -> Double
fmod x y = x - n * y
  where n = roundDown $ x / y 

limitAngle :: Angle -> Angle
limitAngle = flip fmod $ 2 * pi

moveAngle :: Angle -> Angle -> Angle
moveAngle a1 a2 = (a1 + a2) `fmod` (2 * pi)

data SphereAngles = SphereAngles {
  polar :: Angle
, azimuthal :: Angle
} deriving (Eq, Show)

sphereAnglesEq :: SphereAngles -> SphereAngles -> Bool
sphereAnglesEq (SphereAngles theta1 phi1) (SphereAngles theta2 phi2) =
  (theta1 `fmod` (2 * pi)) `doubleEq` (theta2 `fmod` (2 * pi)) &&
  (phi1 `fmod` (2 * pi)) `doubleEq` (phi2 `fmod` (2 * pi))

normalize :: SphereAngles -> SphereAngles
normalize (SphereAngles theta phi) =
  let (theta', phi')
    | theta < 0 = (-theta, phi + pi)
    | theta > pi = (2 * pi - theta, phi + pi)
    | otherwise = (theta, phi)
  in SphereAngles (limitAngle theta') (limitAngle phi')

rotate :: SphereAngles -> SphereAngles -> SphereAngles
rotate (SphereAngles theta

data Position = SpherePosition SphereAngles | DiskPosition Int
  deriving (Eq, Show)

positionEq :: Position -> Position -> Bool
positionEq (SpherePosition p1) (SpherePosition p2) =
  p1 `sphereAnglesEq` p2
positionEq _ _ = undefined

createSpherical :: Angle -> Angle -> Position
createSpherical theta phi =
  SpherePosition $ SphereAngles theta' phi'
  where theta' = theta `fmod` (2 * pi)
        phi' = phi `fmod` (2 * pi)

move :: Position -> Position -> Position
move (SpherePosition p1) (SpherePosition p2) =
  SpherePosition $ p1 `rotate` p2
move _ _ = undefined
