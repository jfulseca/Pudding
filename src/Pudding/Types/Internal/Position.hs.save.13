module Pudding.Types.Internal.Position

( Angle
, Position(..)
, SphereAngles(..)
, createSpherical
, move
, positionEq
) where

import Pudding.Utilities.DoubleFunctions

type Angle = Double

roundDown :: Double -> Double
roundDown = fromIntegral . floor

fmod :: Double -> Double -> Double
fmod x y = x - n * y
  where n = roundDown $ x / y 

limitAngle :: Angle -> Angle
limitAngle = flip fmod $ 2 * pi

data SphereAngles = SphereAngles {
  polar :: Angle
, azimuthal :: Angle
} deriving (Eq, Show)

normalize :: SphereAngles -> SphereAngles
normalize (SphereAngles theta phi) =
  SphereAngles (limitAngle theta') (limitAngle phi') where
    (theta', phi')
      | theta < 0 = (-theta, phi + pi)
      | theta > pi = (2 * pi - theta, phi + pi)
      | otherwise = (theta, phi)

sphereAnglesEq :: SphereAngles -> SphereAngles -> Bool
sphereAnglesEq (SphereAngles theta1 phi1) (SphereAngles theta2 phi2) =
  theta1' `doubleEq theta2' && phi1' doubleEq phi2'

rotate :: SphereAngles -> SphereAngles -> SphereAngles
rotate (SphereAngles theta1 phi1) (SphereAngles theta2 phi2) =
  normalize $ SphereAngles (theta1 + theta2) (phi1 + phi2)

data Position = SpherePosition SphereAngles | DiskPosition Int
  deriving (Show)

positionEq :: Position -> Position -> Bool
positionEq (SpherePosition p1) (SpherePosition p2) =
  p1 `sphereAnglesEq` p2
positionEq _ _ = undefined

createSpherical :: Angle -> Angle -> Position
createSpherical theta phi =
  SpherePosition $ angles
    where angles = normalize $ SphereAngles theta phi

move :: Position -> Position -> Position
move (SpherePosition p1) (SpherePosition p2) =
  SpherePosition $ p1 `rotate` p2
move _ _ = undefined
